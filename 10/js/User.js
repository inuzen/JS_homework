console.log("Task 3");


function User(){
  this.toString = function(){
      return "Anonymous user";
  }
}

User.logged = function(credentials){
  let user = new User();
  user.name = credentials.name;
  user.age = credentials.age;
  user.toString = function(){
    return `Пользователь ${this.name}, возраст: ${this.age}`;
  }
  return user;
}

let user = new User();
console.log(user.toString());
let logged = User.logged({name:"inuzen", age:25});
console.log(logged.toString());


console.log("Task 4");

//Объект JSON
// JSON является синтаксисом для сериализации объектов, массивов, чисел, строк логических значений и значения null
//Имеет 2 метода: strigify и parse. Первый преобразует json в строку, а второй наоборот
//в основном используется для передачи данных между фронтом и бэком

//Объект Generator
//создается с помощью функции-генератора. Вместо return возращает значения по-очереди через yield пока такие значения
//не кончаться(далее undefined). Можно использовать для бесконечных итераторов с сохранением значения или делать сложные конструкции с перебором

//объект Promise
// используется для отложенных и асинхронных вычислений. Promise может находиться в трёх состояниях:
// ожидание (pending): начальное состояние, не выполнено и не отклонено.
// выполнено (fulfilled): операция завершена успешно.
// отклонено (rejected): операция завершена с ошибкой.

//Промис используется для выполнения асинхронных функций в синхронном режиме. Только вместо
//значения передает обещание получить это значения кога-то после. Когда обещанное значение вернется
//то вызовется обработчик в соответсвии с успешным или не успешным завершением операции

//объект ArrayBuffer
//используется для работы с бинарными данными. Он представляет собой ссылку на поток "сырых" двоичных данных,
// однако работать с ними напрямую возможности не дает. Вместо этого, вы можете создать типизированный массив
// или объект DataView, который можно использовать для чтения и записи данных в ArrayBuffer.

//Объект DataView
//Вид DataView предоставляет низко-уровневый интерфейс для чтения и записи многочисленных числовых типов
// в бинарном ArrayBuffer, независимо от порядка байтов платформы.

//Объект Set
// Объекты Set представляют коллекции значений, по которым вы можете выполнить обход в порядке вставки элементов.
// Значение элемента в Set может присутствовать только в одном экземпляре, что обеспечивает его уникальность в коллекции Set.
//Можно использовать когда требуется набор данных в котором каждое значение должно быть в единственном экземпляре
//При добавлении стринг в сет произойдет деконструкция

//Объект Map
//Map это вид объекта, в котором ключами может быть не только string, но любой примитивный тип данных
//итерируется подряд с помощью for...of

// Объект Async function
// Объекты async function, созданные с помощью AsyncFunction constructor  будут распарсены в момент, когда функция создается.
//  Это менее эффективно, чем объявлять асинхронную функцию с помощью async function expression и вызывать ее внутри вашего кода,
//  поскольку такие функции анализируются с остальной частью кода.
// AsyncFunction constructor , не создают замыкания на создающие их контексты; Они всегда создаются в глобальной области видимости.
//  При их запуске они смогут получить доступ только к своим локальным переменным и к глобальным переменным, но не имеют доступа к
//  тем областям видимости, в которых был вызван AsyncFunction constructor.

// Объект Atomics
//  предоставляет атомарные операции как статические методы. Используется вместе с объектом SharedArrayBuffer.
//  Атомарные операции установлены в модуле Atomics. В отличие от других глобальных объектов, Atomics не является конструктором.
//  Его нельзя использовать вместе с оператором new или вызывать объект Atomics как функцию. Все свойства и методы Atomics статические
